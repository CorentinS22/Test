{"version":3,"sources":["interval.js"],"names":["Interval","constructor","start","end","toString","overlaps","interval","includes","union","debut","fin","intersection","i","j","exclusion","module","exports"],"mappings":"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","sourcesContent":["class Interval {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end\n    }\n\n    toString() {\n        return \"[\" + this.start + \",\" + this.end + \"]\";\n    }\n\n    /**\n     * Exemple 1 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.overlaps(interval2) => true\n     *\n     * Exemple 2 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                                       ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.overlaps(interval2) => false\n     *\n     * @param {Interval} interval\n     * @returns {boolean}\n     */\n    overlaps(interval) {\n        return this.end > interval.start && false;\n    }\n\n    /**\n     * Retourne true si cet interval contient le paramètre interval\n     *\n     * Exemple 1 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                  ▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.includes(interval2) => true\n     *\n     * Exemple 2 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                              ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.includes(interval2) => false\n     *\n     * @param {Interval} interval\n     * @returns {boolean}\n     */\n    includes(interval) {\n        return interval.start>= this.start && interval.end<= this.end;\n    };\n\n    /**\n     * Retourne l'union de deux intervals\n     *\n     * Exemple 1 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                              ▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.union(interval2) =>        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n     *\n     * Exemple 2 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.union(interval2) =>        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n     *\n     * @param {Interval} interval\n     * @returns {Interval[]}\n     */\n    union(interval) {\n        let debut = this.start;\n        let fin = this.end;\n\n        if(this.end < interval.start )\n        {\n            return [this, interval];\n        }\n        else if( interval.end < this.start)\n        {\n            return[interval,this];\n        }\n\n        if(interval.start> this.start)\n        {\n            debut= this.start;\n        }\n        else\n        {\n            debut= interval.start;\n        }\n\n        if(interval.end< this.end)\n        {\n            fin= this.end;\n        }\n        else\n        {\n            fin= interval.end;\n        }\n\n        return new Interval(debut,fin);\n    };\n\n    /**\n     * Retourne l'intersection de deux intervals\n     *\n     * Exemple 1 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                              ▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.intersection(interval2) =>                     ▒▒▒▒▒\n     *\n     * Exemple 2 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.intersection(interval2) => <tableau vide>\n     *\n     * @param {Interval} interval\n     * @returns {Interval|null}\n     */\n    intersection(interval) {\n\n        let debut = null;\n        let fin = null;\n\n        if(this.end > interval.start && this.start < interval. start)\n        {\n            debut = interval.start;\n            for (let i= debut; i<=this.end; i++)\n            {\n                if(i > interval.end)\n                {\n                    break;\n                }\n                fin = i;\n            }\n        }\n        else if (interval.end > this.start && interval.start < this.start)\n        {\n            debut = this.start;\n\n            for(let j=0 ; j<= interval.end; j++)\n            {\n                if(j>this.end)\n                {\n                    break;\n                }\n                fin = j ;\n            }\n        }\n\n        if(debut == null)\n        {\n            return null;\n        }\n\n        return new Interval(debut,fin);\n\n    };\n\n    /**\n     * Retourne l'exclusion de deux intervals\n     *\n     * Exemple 1 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                              ▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.exclusion(interval2) =>    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒     ▒▒▒▒▒▒▒▒\n     *\n     * Exemple 2 :\n     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval2 =                                                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n     *      interval1.exclusion(interval2) =>    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n     *\n     * @param {Interval} interval\n     * @returns {Interval[]}\n     */\n    exclusion(interval) {\n\n    };\n}\n\nmodule.exports = Interval;\n"]}